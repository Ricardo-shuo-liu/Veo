# Veo 内存安全
Veo 整合了 Rust 风格的内存安全机制，同时保留了 C++ 级别的底层控制能力——在安全性与灵活性之间取得平衡，可同时满足应用层和系统层开发需求。复合类型（数组、列表、元组、字典）的设计充分考虑了内存安全与精准控制的双重需求。

## 1. 核心内存安全原则
Veo 默认通过以下机制保障内存安全：
- **所有权模型**：每个值有且仅有一个所有者（避免双重释放问题，适用于所有复合类型）
- **借用规则**：对借用数据的访问进行严格管控（避免使用已释放的内存）
- **自动内存管理**：无需手动分配/释放内存（避免内存泄漏；强/弱复合类型均由系统自动管理）
- **不安全代码块**：为系统开发场景提供可选的底层控制能力（显式执行不安全操作）

## 2. 所有权模型（含复合类型）
### 2.1 基本所有权规则
1. Veo 中的每个值（包括数组、列表、元组、字典）有且仅有一个所有者
2. 当所有者超出作用域时，对应值会被自动释放
3. 所有权可转移（移动语义），但不可复制

### 2.2 语法示例（复合类型的所有权）
```veo
# 强类型数组的所有权（固定长度）
def create_strong_array() -> int[5]:
    int[5] arr = [1, 2, 3, 4, 5]  # arr 是该强类型数组的所有者
    return arr  # 所有权转移给调用方

# 弱类型列表的所有权（动态长度）
def create_weak_list() -> list[]:
    list[] info = [1, "Veo", 3.14]  # info 是该列表的所有者
    return info  # 所有权转移

# main函数获取复合类型的所有权
int[5] nums = create_strong_array()
list[] mixed_list = create_weak_list()

print(nums[0])        # 合法：nums 是当前所有者
print(mixed_list[1])  # 合法：mixed_list 是当前所有者

# nums/mixed_list 在此处超出作用域 → 内存被自动释放
```

### 2.3 所有权转移（移动语义）
```veo
let a: list[] = [1, "a", 3.14]  # a 拥有该弱类型列表的所有权
let b = a                      # 所有权转移至 b（a 不再有效）
# print(a[0])  # 错误：a 已不再拥有列表所有权

# 克隆（显式复制，创建新所有者）
let c = b.clone()  # c 成为新所有者（b 仍保持有效）
print(b[0])        # 合法：b 拥有原始列表的所有权
print(c[0])        # 合法：c 拥有克隆列表的所有权

# 强类型元组的所有权转移
tuple[3] d = (1, "b", true)
tuple[3] e = d  # 所有权转移至 e（d 失效）
# print(d[0])  # 错误：d 已不再拥有强类型元组所有权
```

## 3. 借用规则（含复合类型）
### 3.1 基本借用规则
1. 同一时间只能存在一个可变借用，或多个不可变借用（二者不可并存）
2. 借用的生命周期不能超过所有者的生命周期
3. 不可变借用（只读）与可变借用（可读可写）严格区分

### 3.2 语法示例（复合类型的借用）
```veo
int[5] nums = [1, 2, 3, 4, 5]  # 强类型数组
dict[] info = {"a": 1, "b": 2}  # 弱类型字典

# 强类型数组的不可变借用（只读）
let &ref1 = nums  # & 表示不可变借用
let &ref2 = nums  # 允许多个不可变借用
print(ref1[0])    # 合法：只读访问

# 弱类型字典的可变借用（可读可写）
let &mut ref3 = info  # &mut 表示可变借用
# let &ref4 = info    # 错误：可变借用期间不允许存在不可变借用
ref3["c"] = 3         # 合法：通过可变借用修改数据
print(info["c"])       # 输出：3

# 所有者转移后，借用失效
let new_nums = nums  # 所有权转移至 new_nums
# print(ref1[0])     # 错误：借用的生命周期超过所有者
```

## 4. 复合类型的内存安全特性
### 4.1 强类型复合类型（固定长度）
- **安全性**：固定长度设计防止缓冲区溢出（编译期校验）
- **内存控制**：精准分配内存（无动态扩容带来的内存浪费）
- **适用场景**：对内存使用稳定性有要求的生产环境

### 4.2 弱类型复合类型（动态长度）
- **安全性**：自动内存管理（扩容/缩容过程无内存泄漏）
- **灵活性**：类 Python 的动态操作（追加元素、新增键值对等）
- **适用场景**：原型开发或长度不可预测的业务场景

### 4.3 元组的专属安全特性（不可变性）
- 类 Python 的不可变性（创建后无法修改元素）
- 防止数据被意外修改（只读场景下具备线程安全性）

## 5. 不安全代码块（底层控制）
针对系统级开发场景（如 C/C++ 互操作、手动内存管理），可通过 `unsafe` 代码块主动退出安全校验机制（支持所有复合类型）：
### 5.1 语法示例（复合类型的不安全代码块）
```veo
# 安全代码（默认）
int[3] safe_strong_arr = [1, 2, 3]
list[] safe_weak_list = [4, "a", 5.6]

# 不安全代码块（显式执行底层操作）
unsafe {
    # 为强类型数组手动分配内存（C 风格）
    int* ptr = malloc(sizeof(int) * 3)  # 裸指针
    
    # 直接内存访问（将 safe_strong_arr 数据拷贝至 ptr）
    for int i in range(0, 3):
        ptr[i] = safe_strong_arr[i]
    print(ptr[0])  # 输出：1
    
    # 手动释放内存（必须执行，避免泄漏）
    free(ptr)
}
```

### 5.2 不安全代码块的核心规则
- `unsafe` 代码块为显式声明（代码评审时可清晰识别）
- 开发者需对 `unsafe` 代码块内的内存安全负责（包括复合类型操作）
- 仅在必要时使用 `unsafe`（如系统编程、外部函数接口 FFI 场景）

## 6. 无全局解释器锁（GIL）
Veo 移除了 Python 的全局解释器锁（GIL）——支持真正的并行计算和高并发处理（适用于所有复合类型）：
```veo
# 基于弱类型列表的高并发异步操作（无 GIL 限制）
async def process_list(list[] data) -> list[]:
    let result: list[] = []
    for item in data:
        if type(item) == int:
            result.append(item * 2)
    return result

# 并行运行多个异步任务
def main():
    let weak_lists = [[1, "a", 3], [4, "b", 5], [6, "c", 7]]
    for arr in weak_lists:
        spawn(process_list(arr))  # 为弱类型列表启动并行任务
```
---